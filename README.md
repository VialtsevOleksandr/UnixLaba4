# Недетермінований скінчений автомат (NFA)

## Опис програми

Ця програма реалізує недетермінований скінчений автомат (NFA), який може одночасно перебувати у декількох станах. Програма читає автомат із вхідного файлу, моделює його роботу та перевіряє, чи автомат допускає задане слово.

## Особливості програми

- **Неповна детермінованість**: автомат може одночасно перебувати у кількох станах і обробляти переходи за символами, що дозволяє моделювати недетермінізм.
- **Підтримка множини переходів**: програма підтримує функції переходів, де один стан може переходити до кількох нових станів за тим самим символом.
- **Вхідний алфавіт**: автомат працює з обмеженою кількістю малих англійських літер, які вказуються у вхідному файлі.
- **Формат вхідного файлу**: вхідний файл описує автомат у певному форматі (див. нижче).

## Формат вхідного файлу

Файл має містити наступні рядки:
1. Потужність вхідного алфавіту (`||A||`). Програма автоматично заповнює алфавіт малими англійськими літерами від `a` до потрібного числа.
2. Кількість станів (`||S||`).
3. Початковий стан (`s0`).
4. Кількість фінальних станів і перелік самих фінальних станів (`||F||`).
5. Переходи між станами у форматі `s a s'`, де `s` — початковий стан, `a` — символ алфавіту, `s'` — кінцевий стан.

### Приклад файлу

![image](https://github.com/user-attachments/assets/ae07a498-0014-442f-b4f7-5373836a63d5)

##  Як це працює
1. **Користувачу пропунується набір кнопок для взаємодії з програмою за допомогою функції `printINFO`**
```
void printINFO()
{
    cout << YELLOW << "-----------------------------\n";
    cout << "Menu:\n";
    cout << "1. Select file\n";
    cout << "2. Print NFA information\n";
    cout << "3. Exit\n";
    cout << "-----------------------------\n" << RESET;
    cout << "Enter your choice: ";
}
```
2. **Користувач вводить назву файлу і викликається функція `loadNFA`, яка зчитує дані з файлу заповнюючи структуру `NFA`**
```
struct NFA {
    unordered_set<char> alphabet; // Множина символів вхідного алфавіту
    unordered_set<int> states; // Множина станів S
    unordered_set<int> finalStates; // Множина фінальних станів F
    int startState; // Початковий стан s0
    unordered_map<int, unordered_map<char, vector<int>>> transitions; // Функція переходів f
};
```
  Тобто це і є наш автомат.

3. **Користувачу відображаються символи з якими працює автомат і пропонується ввести слово на перевірку, чи допускається воно автоматом?**

  Також відбувається перевірка на коректність символів з слова, яке ввів користувач і вже після цього викликається функція `acceptsWord`
```
bool validWord = true;
string invalidSymbols;
for (char c : inputWord) {
    if (nfa.alphabet.find(c) == nfa.alphabet.end()) {
        validWord = false;
        invalidSymbols += c;
        invalidSymbols += " ";
    }
}

if (!validWord) {
    cout << RED << "The word contains invalid symbols for NFA: " << invalidSymbols << RESET << endl;
    continue;
}
```
4. **Відбувається перевірка слова за допомогою функції `acceptsWord`**
```
bool acceptsWord(const NFA& nfa, const string& word) {
    unordered_set<int> currentStates = { nfa.startState };

    for (char symbol : word) {
        unordered_set<int> nextStates;
        for (int state : currentStates) {
            if (nfa.transitions.count(state) && nfa.transitions.at(state).count(symbol)) {
                const vector<int>& transitions = nfa.transitions.at(state).at(symbol);
                nextStates.insert(transitions.begin(), transitions.end());
            }
        }
        if (nextStates.empty()) {
            return false; // Якщо немає можливих переходів
        }
        currentStates = nextStates;
    }

    // Перевірка, чи один із поточних станів є фінальним
    for (int state : currentStates) {
        if (nfa.finalStates.find(state) != nfa.finalStates.end()) {
            return true;
        }
    }

    return false;
}
```
Ця функція реалізує модель недетермінізму, де автомат може одночасно перебувати у кількох станах. Ось детальний опис її роботи:

### Вхідні параметри
`const NFA& nfa`: константне посилання на структуру `NFA`, яка містить всю інформацію про автомат, включаючи стани, алфавіт, переходи тощо.

`const string& word`: слово, яке перевіряється на допустимість автоматом.
### Вихідне значення
Функція повертає `true`, якщо слово допускається автоматом, тобто існує шлях від початкового стану до одного з фінальних станів при зчитуванні символів слова.

Повертає `false`, якщо слово не допускається.

### Алгоритм роботи

1. **Ініціалізація початкових станів:**
- Створюється множина `currentStates`, що містить лише початковий стан автомата `nfa.startState`.

2. **Ітерація по символах слова:**
- Для кожного символу з `word`:
  - Ініціалізується порожня множина `nextStates`, яка буде містити нові стани, в які може перейти автомат після обробки поточного символу.
  - Для кожного стану `state` у множині `currentStates`:
    - Перевіряється наявність переходів для поточного символу. Якщо існують переходи для `state` і `symbol`, витягуються всі можливі кінцеві стани.
    - Додаються ці кінцеві стани до множини `nextStates`.
  - Після обробки поточного символу перевіряється, чи множина `nextStates` не порожня. Якщо вона порожня, автомат не може перейти в новий стан, і функція повертає `false`.

3. **Оновлення поточних станів:**
- Множина `currentStates` оновлюється значенням `nextStates`, тобто тепер автомат знаходиться в нових можливих станах після обробки поточного символу.

4. **Перевірка фінальних станів:**
- Після обробки всіх символів слова функція перевіряє, чи один із станів у `currentStates` є фінальним станом (тобто чи належить множині `nfa.finalStates`).
  - Якщо хоча б один стан у `currentStates` є фінальним, функція повертає `true`.
  - Якщо жоден із поточних станів не є фінальним, функція повертає `false`.

## Приклад використання
На вхід будемо використовувати файл прикладу (див. вище).

Якщо візуалізувати цей автомат, то отримаємо наступне:
  
<img src="https://github.com/user-attachments/assets/460c01b6-f3e7-4aa3-b7ca-66933c365687" alt="NFA Visualization" width="300"/>

Тоді легко помітити, що слово 'aab' -  не допускається заданим автоматом, а слово 'aaba' - допускається. Тобто наша програма працює коректно.

![image](https://github.com/user-attachments/assets/0cacd724-cdbf-4877-addd-f59203e5abb8)

